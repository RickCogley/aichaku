import type { NagareConfig } from "@rick/nagare/types";
import { TemplateFormat } from "@rick/nagare/types";

export default {
  project: {
    name: "Aichaku (æ„›ç€)",
    description:
      "AI-optimized project methodology installer for Claude Code - brings affection (æ„›ç€) to your development workflow",
    repository: "https://github.com/RickCogley/aichaku",
    homepage: "https://github.com/RickCogley/aichaku",
    license: "MIT",
    author: "Rick Cogley",
  },

  versionFile: {
    path: "./version.ts",
    template: TemplateFormat.CUSTOM,
    customTemplate: `/**
 * Version information for {{ project.name |> safe }}
 * Generated by Nagare on {{ buildDate |> safe }}
 *
 * Note: This template generates TypeScript code, not HTML.
 * The |> safe filter is used to output raw values without escaping.
 */

export const VERSION = "{{ version |> safe }}";

export const BUILD_INFO = {
  buildDate: "{{ buildDate |> safe }}",
  gitCommit: "{{ gitCommit |> safe }}",
  buildEnvironment: "{{ buildEnvironment |> safe }}",
  versionComponents: {
    major: {{ versionComponents.major |> safe }},
    minor: {{ versionComponents.minor |> safe }},
    patch: {{ versionComponents.patch |> safe }},
    prerelease: {{ if versionComponents.prerelease }}{{ versionComponents.prerelease |> safe }}{{ else }}null{{ /if }},
  },
} as const;

export const APP_INFO = {
  name: "{{ project.name |> safe }}",
  description: "{{ project.description |> safe }}",
  repository: "{{ project.repository |> safe }}",
  author: "{{ project.author |> safe }}",
  homepage: "{{ project.homepage |> safe }}",
  license: "{{ project.license |> safe }}",
} as const;

export const APP_METADATA = {} as const;

export const RELEASE_NOTES = {{ releaseNotesJson |> safe }} as const;`,
  },

  updateFiles: [
    {
      path: "./deno.json",
      updateFn: (content: string, data: { version: string }) => {
        // Parse the JSON to safely update only the top-level version
        try {
          const config = JSON.parse(content);
          config.version = data.version;
          return JSON.stringify(config, null, 2);
        } catch (_error) {
          // Fallback to regex if JSON parsing fails
          return content.replace(
            /^(\s*"version":\s*)"[^"]+"/m,
            `$1"${data.version}"`,
          );
        }
      },
    },
    {
      path: "./README.md",
      // Using built-in handler for standard badge format
    },
    {
      path: "./mod.ts",
      patterns: {
        version: /(\| Version \| )([^\s]+)( \|)/,
      },
      updateFn: (content: string, data: { version: string }) => {
        return content.replace(
          /(\| Version \| )([^\s]+)( \|)/,
          `$1${data.version}$3`,
        );
      },
    },
    {
      path: "./.claude/aichaku/user/app-description.yaml",
      updateFn: (content: string, data: { version: string }) => {
        // Update the version field in the YAML
        return content.replace(
          /^(\s*version:\s*)"[^"]+"/m,
          `$1"${data.version}"`,
        );
      },
    },
  ],

  releaseNotes: {
    includeCommitHashes: true,
    maxDescriptionLength: 120,
  },

  github: {
    owner: "RickCogley",
    repo: "aichaku",
    createRelease: true,
  },

  options: {
    tagPrefix: "v",
    gitRemote: "origin",
  },

  release: {
    // Disable default test runner and use custom one with permissions
    preflightChecks: {
      runTests: false, // Disable default
      custom: [
        {
          name: "Test Suite",
          command: ["deno", "test", "--no-check", "--allow-read", "--allow-write", "--allow-env", "--allow-run"],
          description: "Runs all unit and integration tests with required permissions",
          fixable: false,
        },
      ],
    },

    // Verify package appears on JSR after release
    verifyJsrPublish: true,

    // Auto-fix configuration for CI/CD errors
    autoFix: {
      basic: true, // Enable deterministic fixes
      ai: {
        enabled: true, // Enable AI-powered fixes
        provider: "claude-code",
        // Choose thinking level based on your plan:
        // - "think": Basic analysis (lowest token usage)
        // - "megathink": Deeper analysis (medium token usage)
        // - "ultrathink": Deepest analysis (highest token usage)
        thinkingLevel: "ultrathink", // You have the max plan
        maxAttempts: 5,
      },
      types: [
        "lint",
        "format",
        "security-scan",
        "type-check", // Re-enabled: deno check now respects top-level exclude
        "version-conflict",
      ],
    },

    // Progress visualization
    progress: {
      enabled: true,
      style: "detailed",
      showElapsedTime: true,
    },

    // GitHub Actions monitoring
    monitoring: {
      workflowFile: ".github/workflows/publish.yml",
      pollInterval: 10000, // 10 seconds
      timeout: 600000, // 10 minutes
    },
  },

  docs: {
    enabled: false, // Temporarily disabled due to Nagare dependency issue
    outputDir: "./docs/api",
    includePrivate: false,
  },

  hooks: {
    preRelease: [
      async () => {
        console.log("ğŸ” Running format check...");
        // Use standard deno fmt check
        const fmtCheck = new Deno.Command("deno", {
          args: ["fmt", "--check"],
        });
        const fmtResult = await fmtCheck.output();
        if (!fmtResult.success) {
          throw new Error("Format check failed");
        }

        console.log("ğŸ” Running linter...");
        const lintCmd = new Deno.Command("deno", {
          args: ["lint"],
        });
        const lintResult = await lintCmd.output();
        if (!lintResult.success) {
          throw new Error("Lint check failed");
        }

        console.log("ğŸ” Running type check...");
        const checkCmd = new Deno.Command("deno", {
          args: ["check"], // No args = respects top-level exclude
        });
        const checkResult = await checkCmd.output();
        if (!checkResult.success) {
          throw new Error("Type check failed");
        }

        // Tests are now run via custom preflight check with --no-check flag
        console.log("âœ… All pre-release checks passed");
      },
    ],
    postRelease: [
      async () => {
        console.log("ğŸ”¨ Building and uploading binaries...");

        // Run build-binaries script with --upload flag (builds + uploads)
        const buildCmd = new Deno.Command("deno", {
          args: ["run", "-A", "./scripts/build-binaries.ts", "--upload"],
          stdout: "inherit",
          stderr: "inherit",
        });

        const buildResult = await buildCmd.output();
        if (!buildResult.success) {
          console.error(
            "âš ï¸  Binary building/upload failed - continuing anyway",
          );
          // Don't throw - this is post-release, so the release already succeeded
        } else {
          console.log("âœ… Binaries built and uploaded to GitHub release");
        }
      },
    ],
  },
} satisfies NagareConfig;
